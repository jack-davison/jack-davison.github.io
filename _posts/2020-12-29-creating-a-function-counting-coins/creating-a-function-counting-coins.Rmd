---
title: "The Minimum Coins Problem in Base R"
description: |
  An R-based solution to a common programming challenge - for a given value of money, what is the minimum number of coins to make the change?
author:
  - name: Jack Davison
    # url: https://example.com/norajones
date: 12-29-2020
categories:
  - tutorial
output:
  distill::distill_article:
    self_contained: false
    code_folding: true
    toc: true
    toc_depth: 2
    toc_float: true

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=7, fig.height=6, fig.align="center")
```

# Setting the scene

The internet is awash with common programming "interview-style" challenges, perhaps most famously ["fizzbuzz"](https://www.tomdalling.com/blog/software-design/fizzbuzz-in-too-much-detail). A problem that I recently became aware of was the ["minimum coins" puzzle](https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-change/), defined as such:

> Given a value V, if we want to make change for V cents, and we have infinite supply of each of C = { C1, C2, .. , Cm} valued coins, what is the minimum number of coins to make the change?

The linked blog features answers for many languages - C++, Java, Python, etc. - but R is a notable omission. I thought I'd try to generate a complementary answer, so if anyone happens to Google an R-based answer, here it will be!

# Writing a basic function

When I write a function, I try to write the most basic workable version of it first. My thoughts going into this were as follows:

1. As a first step, we'll need to define the coins we'll be using. As I'm British, I'll use GBP.

1. We'll then need to find the greatest value coin that itself is greater than the value, *V*, which we can call *B*.

1. Once we have identified *B*, we'll need to subtract *B* from *V* and repeat from Step 2 until *V* = 0.

1. We'll need to count each iteration of Steps 2-3 and return that counted value.

My attempt is given below:

```{r}

count_coins = function(v){
  
  coins = c(1, 2, 5, 10, 20, 50, 100, 200)

  result = c()
  
  while(v > 0){
    
    b = max(coins[coins <= v])
    
    result = append(result, b)
    
    v = v - b
    
  }
  
  return(length(result))

}

```

Here the available coins are stored as a vector named `coins`. I've chosen not to use decimals (i.e. 2p = 2, not .02) for a reason that will become apparent later. I then have an empty `results` vector which will become populated with our coins.

I then use the R function `while()`, which loops until the condition inside is no longer met. In this case, I have specified that while *V* is greater than 0, the contents within should loop. Those contents identify the greatest value in the `coins` vector that's greater than or equal to *V*, add it to our `results` vector, and then subtract it from *V*.

The function finally returns the length of the *results* vector. So now, in theory, we can provide our function any values in pence and it'll return the minimum number of coins you'd need. So for example, if we use *V* = 8 we'd expect 3 coins - 5p + 2p + 1p.

```{r}

count_coins(v = 8)

```
As the UK has 10p coins, *V* = 10 should return 1 coin.

```{r}
count_coins(v = 10)
```
We could also throw it a larger amount of money - let's say £5.12 (*V* = 512). I would predict £2 + £2 + £1 + 10p + 2p = 5 coins.

```{r}
count_coins(v = 512)
```

Looking good!

# Expanding the function

## Returning the list of coins

This would hopefully tick whatever box the interviewer was looking to tick, but we can do better. If we were a frequent counter of coins, we may want additional features. For example, we may want an option to return the actual coins rather than simply the number of them. This will also be a good double-check that the function isn't doing anything wacky behind the scenes and just happening upon the correct answer! It is also a pretty easy addition:

```{r}

count_coins = function(v, return_coins = F){
  
  coins = c(1, 2, 5, 10, 20, 50, 100, 200)

  result = c()
  
  while(v > 0){
    
    b = max(coins[coins <= v])
    
    result = append(result, b)
    
    v = v - b
    
  }
  
  if (return_coins) {
    return(result)
  } else {
    return(length(result))
  }
  

}

```

Let's revisit the arbitrary value of £5.12.

```{r}
count_coins(v = 512, return_coins = F)
count_coins(v = 512, return_coins = T)
```

## Allowing for similar currencies

Another obvious addition could be the addition of different currencies other than GBP. There are two ways we could approach this:

- We could allow users to enter their own vector of coins.

- We could allow users to enter a currency code and have these values built-in, e.g. "GBP", "USD", "JPY", etc.

There is no reason, however, to not do both! Such is the flexibility of writing functions in R. I will add a feature that checks to see if the user has entered a character string or numeric vector. 

- If the user has entered a character string, it will check it against the hard-coded coin values and give a warning if whatever they have specified is not included.

- If the user has entered a numeric vector, it will set the `coins` vector to be equal to it. To avoid infinite loops, it will also append the number 1.

For the sake of this example, I'm going to hard-code the Great British Pound, the Euro, the US Dollar, and the Japanese Yen as three common currencies. This is the reason I did not use decimals - the Japanese Yen does not, and it would only serve to introduce awkwardness if we want to make comparisons between the different coin types (spoilers: that is coming next!).

```{r}

count_coins = function(v, return_coins = F, coin_vals = "GBP"){
  
  if (is.character(coin_vals)) {
    if (coin_vals %in% c("GBP", "EUR")) {
      coins = c(1, 2, 5, 10, 20, 50, 100, 200)
    } else if (coin_vals == "USD") {
      coins = c(1, 5, 10, 25, 50, 100)
    } else if (coin_vals == "JPY") {
      coins = c(1, 5, 10, 50, 100, 500)
    } else {
      warning(
        paste0(
          "The currency '",
          coin_vals,
          "' is not supported. Supported currencies are GBP, EUR, USD, and JPY.
          Alternatively, provide a vector of numeric coin values."
        )
      )
      stop()
    }} else if (is.numeric(coin_vals)) {
    coins = append(coin_vals,1)
  }
  
  result = c()

  while(v > 0){

    b = max(coins[coins <= v])

    result = append(result, b)

    v = v - b

  }

  if (return_coins) {
    return(result)
  } else {
    return(length(result))
  }


}

```

Let's try a few examples:

```{r error=TRUE, message=T, warning=T}
count_coins(v = 512, return_coins = T, coin_vals = "EUR")
count_coins(v = 512, return_coins = T, coin_vals = "USD")
count_coins(v = 512, return_coins = T, coin_vals = "JPY")
count_coins(v = 512, return_coins = T, coin_vals = c(5,500))
count_coins(v = 512, return_coins = T, coin_vals = "CAD")
```

## The curious case of the Canadian Dollar

In Canada and Australia the decision was made to stop minting coins below a value of 5¢. This is very sensible, but introduces an interesting problem for the function - currently, to avoid infinite recursion, we append a 1¢ (or 1p, or whatever) coin to any list - but this won't actually reflect the situation in Canada or Australia. The [Wikipedia article on the Abolition of the Canadaian penny](https://www.wikiwand.com/en/Penny_(Canadian_coin)#/Abolition) writes:

> Cash transactions are now rounded to the nearest 5¢. The rounding is not done on individual items but on the total bill of sale, with totals ending in 1, 2, 6, or 7 rounded down to 0 or 5, and totals ending in 3, 4, 8, or 9 rounded up.

The solution to this issue could be more complicated than it needs to be. If the question that this function serves to answer is "If I have *V* Canadian cents in my bank account and convert that to cash, how many coins are now in my wallet?" then the value of *V* we use within the `while()` loop will have to be some value that is divisible by five. 

To overcome this, we could simply round *V* down to the nearest multiple of five using the `floor()` function, which is similar to `round()` but always rounds down. Rather than hard-coding a value of 5, I can just identify the smallest unit of currency inside of the `coins` vector and use that - this allows for any coins to be used. Note that this means I can get rid of appending the 1¢ coin to a user-defined numeric vector.

```{r}

count_coins = function(v, return_coins = F, coin_vals = "GBP"){
  
  if (is.character(coin_vals)) {
    if (coin_vals %in% c("GBP", "EUR")) {
      coins = c(1, 2, 5, 10, 20, 50, 100, 200)
    } else if (coin_vals == "USD") {
      coins = c(1, 5, 10, 25, 50, 100)
    } else if (coin_vals == "JPY") {
      coins = c(1, 5, 10, 50, 100, 500)
    } else if (coin_vals == "CAD") {
      coins = c(5, 10, 25, 100, 200)
    } else if (coin_vals == "AUD") {
      coins = c(5, 10, 20, 50, 100, 200)
    } else {
      warning(
        paste0(
          "The currency '",
          coin_vals,
          "' is not supported. Supported currencies are GBP, EUR, USD, CAD, AUD and JPY.
          Alternatively, provide a vector of numeric coin values."
        )
      )
      stop()
      
  }} else if (is.numeric(coin_vals)) {
    coins = coin_vals
  }
  
  v = floor(v/min(coins))*min(coins)

  result = c()

  while(v > 0){

    b = max(coins[coins <= v])
    
    result = append(result, b)

    v = v - b

  }

  if (return_coins) {
    return(result)
  } else {
    return(length(result))
  }


}

```

Let's test this out:

```{r}
count_coins(v = 512, return_coins = T, coin_vals = "CAD")
count_coins(v = 512, return_coins = T, coin_vals = c(10, 20, 60))
```
## Saving users from themselves

This seems to work well, but has highlighted a danger of allowing the manual input of coin values - infinite recursion. For example, the following will loop infinitely:

```{r eval = F}
count_coins(v = 512, return_coins = T, coin_vals = c(9, 23, 64))
```

I have intuited (perhaps incorrectly!) that each coin value needs to be divisible by the lowest coin value to work. So this is an appropriate list of coins and will not loop forever:

```{r}
count_coins(v = 512, return_coins = T, coin_vals = c(9, 27, 63))
```

One way we can stop the function breaking is introducing a check using `all()` and the modulus operator `%%` which stops the function before the loop.

```{r}

count_coins = function(v, return_coins = F, coin_vals = "GBP"){
  
  if (is.character(coin_vals)) {
    if (coin_vals %in% c("GBP", "EUR")) {
      coins = c(1, 2, 5, 10, 20, 50, 100, 200)
    } else if (coin_vals == "USD") {
      coins = c(1, 5, 10, 25, 50, 100)
    } else if (coin_vals == "JPY") {
      coins = c(1, 5, 10, 50, 100, 500)
    } else if (coin_vals == "CAD") {
      coins = c(5, 10, 25, 100, 200)
    } else if (coin_vals == "AUD") {
      coins = c(5, 10, 20, 50, 100, 200)
    } else {
      warning(
        paste0(
          "The currency '",
          coin_vals,
          "' is not supported. Supported currencies are GBP, EUR, USD, CAD, AUD and JPY.
          Alternatively, provide a vector of numeric coin values."
        )
      )
      stop()
      
  }} else if (is.numeric(coin_vals)) {
    coins = coin_vals
  }
  
  v = floor(v/min(coins))*min(coins)
  
  if (!all(coins %% min(coins) == 0)) {
    warning(paste("Ensure all coins are divisible by",
                  min(coins),
                  "to avoid infinite recursion."))
    stop()
  }

  result = c()

  while(v > 0){

    b = max(coins[coins <= v])
    
    if (is.null(b)) {
      stop()
    }

    result = append(result, b)

    v = v - b

  }

  if (return_coins) {
    return(result)
  } else {
    return(length(result))
  }


}

```

Our dodgy set of coins should now fail rather than go on indefinitely:

```{r error = T, message = T, warning = T}
count_coins(v = 512, return_coins = T, coin_vals = c(9, 23, 64))
```

# Insights and Visualisations

With a more fully featured function like this, we can gain some fairly pointless insights about how the values of coins affect the numbers of coins you actually have in your wallet. I'm going to create some visualisations using `ggplot2` and the `tidyverse`. For ease, I'm going to pre-set my theme using the `ggthemr` package.

```{r}
library(tidyverse)
library(ggthemr)

ggthemr::ggthemr(palette = "flat",
                 text_size = 14,
                 layout = "scientific")
```

Let's use our function on values from 1 to 5000 units of currency (i.e. 1p to £50, 1¢ to $50, and ¥1 to ¥5000). We'll use the dplyr function `rowwise()` to facilitate this.

```{r}
df = data.frame(val = 1:5000) %>%
  rowwise() %>%
  mutate(coin_gbp = count_coins(v = val, coin_vals = "GBP"),
         coin_usd = count_coins(v = val, coin_vals = "USD"),
         coin_jpy = count_coins(v = val, coin_vals = "JPY"))

```

Let's plot our findings. This should let us see which set of coin values will give us the fewest number of physical coins on our person. *NB: There is currently a bug in the most recent version of ggthemr; the last line should not be necessary in future!*

```{r}
df %>%
  pivot_longer(contains("coin"),
               names_to = "currency",
               values_to = "number") %>%
  mutate(currency = toupper(str_remove_all(currency, "coin_"))) %>%
  ggplot(aes(x = val, y = number, color = currency)) + 
  geom_point(alpha = .05) +
  geom_smooth(se = F) +
  theme(
    plot.title.position = "plot",
    plot.caption.position = "plot",
    legend.position = "top", 
    plot.margin = unit(rep(1,4), "cm")
  ) +
  labs(x = "Amount of Money", y = "Number of Coins",
       title = "Currency to Coinage",
       subtitle = "How the same decimal amount of money affects the number of coins in your wallet.",
       caption = "Visualisation by Jack Davison (@JDavison_)",
       color = "") +
  scale_color_manual(values = ggthemr::swatch()) 

```

The results are perhaps unsurprising. The US lacks a large coin, so for larger monetary values the number of coins rapidly increase. The GBP lies in the middle, having both a £1 *and* £2 coin. Of most interest is the JPY - the largest coins are ¥100 and ¥500 - ¥400 between them. This large gap magnifies a repeating pattern of a large drop every 500 units of currency.

These relationships appear to be roughly linear, so we could do some linear modelling to transform one currency into the other. The real world use of this is extremely limited, but it answers the question of "if you had X coins in the US, the US suddenly abandoned the 25¢ coin in favour of a 20¢ one and gained a $2 coin, how many coins would you likely have instead?", a question I am sure has plagued economists for centuries!

```{r}
eq = df %>%
  pivot_longer(coin_usd:coin_jpy) %>%
  mutate(name = if_else(name == "coin_usd", "US Dollars/Cents", "Japanese Yen")) %>%
  nest_by(name) %>%
  mutate(mod = list(lm(coin_gbp ~ value, data = data))) %>%
  summarise(broom::tidy(mod)) %>%
  select(name, term, estimate) %>%
  pivot_wider(names_from = term, values_from = estimate) %>%
  janitor::clean_names() %>%
  mutate(equation = glue::glue("y = {round(intercept,2)} + {round(value,2)}x"))

df %>%
  pivot_longer(coin_usd:coin_jpy) %>%
  mutate(name = if_else(name == "coin_usd", "US Dollars/Cents", "Japanese Yen")) %>%
  ggplot(aes(x = value, y = coin_gbp)) +
  geom_abline(color = swatch()[1], lty = 2, size = 1) +
  geom_count(aes(color = name), alpha = .5) +
  geom_smooth(method = "lm", color = swatch()[5]) +
  labs(x = "Number of Local Coins", 
       y = "Number of GB Coins",
       title = "Coinage: What If?",
       subtitle = "What if the US or Japan had coins more like the UK?",
       caption = "Visualisation by Jack Davison (@JDavison_)") +
  geom_text(data = eq, inherit.aes = F, aes(label = equation, x = 10, y = 32.5), size = 4,
            color = swatch()[5]) +
  facet_grid(~name, space = "free", scales = "free_x", switch = "x") +
  theme(legend.position = "top", 
        plot.title.position = "plot",
        plot.caption.position = "plot",
        strip.placement = "outside", 
        plot.margin = unit(rep(1,4), "cm")) +
  guides(color = F) +
  scale_x_continuous(breaks = seq(0,60,10)) +
  scale_color_manual(values = ggthemr::swatch()) 
```

So in this magical scenario where the global community suddenly decides to mint coins in a GBP-style, a US citizen walking around with 10 coins in his pocket would suddenly find himself with only 7. Conversely, a Japanese person would likely find themselves with 14!

# Closing Thoughts

This was simply an exercise in solving a basic programming challenge in Base R, taking the problem further, and then seeing if anything insightful can be seen (answer: not really anything that insightful!).

Is there anything else that could be added to such a function? And is the way of dealing with AUD and CAD the best approach?