[
  {
    "path": "posts/2020-12-30-tutorial-calendar-plots-using-ggplot2/",
    "title": "Tutorial: Calendar Plots using ggplot2",
    "description": "A ggplot2 recreation of an uncommon heat-map visualisation.",
    "author": [
      {
        "name": "Jack Davison",
        "url": {}
      }
    ],
    "date": "2021-01-01",
    "categories": [
      "tutorial",
      "ggplot2"
    ],
    "contents": "\r\n\r\nContents\r\nSetting the scene\r\nCreating a calendar plot in ggplot2\r\nThe grammar of… calendars?\r\nFormatting data for a calendar plot\r\nPlotting the calendar\r\n\r\nClosing thoughts, and calendars “in the wild”\r\n\r\nIf you’re less interested in the journey and just want the finished code, you can find it here.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(lubridate)\r\n\r\ncal_df = openair::mydata %>% \r\n  mutate(day   = day(date),\r\n         wday  = wday(date, label = T), \r\n         week  = week(date), \r\n         month = month(date, label = T, abbr = F), \r\n         year  = year(date),\r\n         wday = factor(wday, c(\"Sat\", \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\"))) %>%\r\n  group_by(month, year) %>%\r\n  mutate(week = week - min(week),\r\n         wu = ws * sin(2 * pi * wd/360),\r\n         wv = ws * cos(2 * pi * wd/360)) %>%\r\n  group_by(day, wday, week, month, year) %>%\r\n  summarise(across(where(is.numeric), mean, na.rm = T)) %>%\r\n  mutate(wd = (atan2(wu, wv) * 360/2/pi) + 180, .keep = \"unused\") %>%\r\n  ungroup()\r\n\r\ndummy = crossing(wday = unique(cal_df$wday),\r\n                 week = unique(cal_df$week),\r\n                 month = unique(cal_df$month))\r\n\r\ncal_df %>%\r\n  filter(year == 2000) %>%\r\n  \r\n  ggplot(aes(x = wday, y = week)) +\r\n  geom_tile(data = dummy, fill = \"grey95\", color = \"white\") +\r\n  geom_tile(aes(fill = nox), color = \"white\") +\r\n  \r\n  geom_spoke(aes(angle = ((-wd+90)/360)*2*pi), radius = .4, arrow = arrow(length = unit(.1,\"cm\"))) +\r\n  geom_point(aes(size = ws)) +\r\n\r\n\r\n  facet_wrap(~month) +\r\n  \r\n  theme_void() +\r\n  theme(axis.text.x = element_text(),\r\n        plot.title.position = \"plot\", \r\n        plot.caption.position = \"plot\",\r\n        plot.title = element_text(size = 20),\r\n        plot.subtitle = element_text(size = 15, color = \"grey40\"),\r\n        plot.caption = element_text(size = 7, color = \"grey50\", hjust = 0)) +\r\n  \r\n  labs(fill = openair::quickText(\"NOx / ppb\"),\r\n       size = openair::quickText(\"Wind Speed / m/s\"),\r\n       title = \"Nitrogen Oxides in Marylebone, London\",\r\n       subtitle = \"How concentrations of nitrogen oxides changed through the year 2000.\\n\",\r\n       caption = \"\\nData from {openair} | Visualisation by Jack Davison (@JDavison_)\") +\r\n  \r\n  scale_y_reverse() +\r\n  scale_x_discrete(labels = c(\"S\",\"S\",\"M\",\"T\",\"W\",\"T\",\"F\")) +\r\n  \r\n  scale_fill_gradientn(colors = openair::openColours(scheme = \"heat\"), \r\n                       na.value = \"grey80\") +\r\n  scale_size(range = c(0,4)) +\r\n\r\n  coord_equal()\r\n\r\n\r\n\r\nSetting the scene\r\nCalendar plots are a relatively uncommon “heat-map” style visualisation, the key benefit of which is that they are an extremely readable and familiar format, even for folks less familiar with more esoteric chart types. After all, even your nan has a calendar up in her kitchen! As an air quality scientist I am most familiar with them from the openair package, which helpfully includes a dummy data-set named mydata and a purpose-built calendarPlot() function.\r\nLet’s first consider the data set, which is defined in the openair documentation as follows:\r\n\r\nThe mydata dataset is provided as an example dataset as part of the openair package. The dataset contains hourly measurements of air pollutant concentrations, wind speed and wind direction collected at the Marylebone (London) air quality monitoring supersite between 1st January 1998 and 23rd June 2005. The data set is a tibble.\r\n\r\nIt contains a date column which contains hourly date-times starting in January 1998, and a series of numeric columns. ws and wd refer to the wind speed and wind direction, and the columns nox through pm25 correspond to concentrations of the named pollutant.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(lubridate)\r\n\r\nopenair::mydata %>% glimpse()\r\n\r\n\r\nRows: 65,533\r\nColumns: 10\r\n$ date <dttm> 1998-01-01 00:00:00, 1998-01-01 01:00:00, 1998-01-0...\r\n$ ws   <dbl> 0.60, 2.16, 2.76, 2.16, 2.40, 3.00, 3.00, 3.00, 3.36...\r\n$ wd   <int> 280, 230, 190, 170, 180, 190, 140, 170, 170, 170, 18...\r\n$ nox  <int> 285, NA, NA, 493, 468, 264, 171, 195, 137, 113, 100,...\r\n$ no2  <int> 39, NA, NA, 52, 78, 42, 38, 51, 42, 39, 34, 38, 41, ...\r\n$ o3   <int> 1, NA, 3, 3, 2, 0, 0, 0, 1, 2, 7, 8, 9, 8, 9, 9, 12,...\r\n$ pm10 <int> 29, 37, 34, 35, 34, 16, 11, 12, 12, 12, 10, 11, 13, ...\r\n$ so2  <dbl> 4.7225, NA, 6.8300, 7.6625, 8.0700, 5.5050, 4.2300, ...\r\n$ co   <dbl> 3.3725, NA, 9.6025, 10.2175, 8.9125, 3.0525, 2.2650,...\r\n$ pm25 <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, ...\r\n\r\nTo keep things simple, let’s consider only the NOx data from the year 2000. In openair, the calendar plot will look like this. The colour of the boxes reflect NOx concentration in ppb, the direction of the arrows reflect wind direction, and the relative size of the arrows correspond to wind speed.\r\n\r\n\r\nopenair::mydata %>% \r\n  filter(lubridate::year(date) == 2000) %>%\r\n  openair::calendarPlot(mydata = ., annotate = \"ws\")\r\n\r\n\r\n\r\n\r\nopenair’s plotting functions were written in lattice before ggplot2 came on the scene. This is directly referenced in the preface of the openair book:\r\n\r\nopenair is a product of the time it was started and used the highly capable lattice package for plotting. This was a time before ggplot2 and the ‘tidyverse’.\r\n\r\nA “DIY” version of the calendar plot will allow for a greater amount of customisation. ggplot2 is also now much more widely used than lattice, so using the former package will hopefully be more comfortable for a greater number of people.\r\nI first realised it was possible to produce calendar plots using ggplot2 after reading Roy Francis’ blog post on the subject, but I intend to take the general outline further than Roy - who made an availability chart - to create an opeanir-style heatmap calendar.\r\nCreating a calendar plot in ggplot2\r\nThe grammar of… calendars?\r\nOn first glance it could be difficult to consider how to translate a calendar layout to a ggplot2 style, but looking to the lattice/openair plot we can translate its layout to ggplot2-style language.\r\nEach month is a facet\r\nThe day of the week (Mon, Tue, Wed, etc.) is the x-axis.\r\nThe week of the month (i.e. “Week 1-4”) is the y-axis.\r\nEach day of the year will be a distinct observation, plotted using a geometry function.\r\nThe pollutant concentration (or whatever else will be heat-mapped) is a fill aesthetic.\r\nTo put pen to paper in ggplot2 one needs to use geom_*() functions. We want to plot a square, which can be achieved by the (in my experience) rarely-used geom_tile(). A simple reproducible example of a “tile-plot” is shown below.\r\n\r\n\r\ncrossing(x = 1:5, y = 1:5) %>%\r\n  mutate(z = rnorm(n = 25)) %>%\r\n  ggplot(aes(x,y, fill = z)) + \r\n  geom_tile() +\r\n  coord_equal()\r\n\r\n\r\n\r\n\r\nFormatting data for a calendar plot\r\nWe need to restructure our data for a calendar plot. An obvious first step can be the extraction of various elements of the date column, which we can achieve using the lubridate package. It has an excellent set of functions that can easily rip apart date-times and label if needed using the label argument.\r\n\r\n\r\ncal_df = openair::mydata %>% \r\n  mutate(day   = day(date),\r\n         wday  = wday(date, label = T), \r\n         week  = week(date), \r\n         month = month(date, label = T, abbr = F), \r\n         year  = year(date))\r\n\r\n\r\n\r\nThere are two further mutations needed here that purely serve to improve the aesthetics of the plot.\r\nwday is turned into a factor starting on Saturday, much like the openair calendar.\r\nweek currently corresponds to the week of the year and not the week of the month, so we convert one to the other using an intermediary group_by().\r\n\r\n\r\ncal_df = cal_df %>% \r\n  mutate(wday = factor(wday, c(\"Sat\", \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\"))) %>%\r\n  group_by(month, year) %>%\r\n  mutate(week = week - min(week))\r\n\r\n\r\n\r\nThe final step is to generate a daily average, as our data’s time resolution is simply too high for a calendar. This is a straightforward group_by()-summarise() step. Here I use a dplyr v1.0.0 feature, across(), to calculate averages for all numeric values (i.e. all of our pollutants and wind speed). This means we can re-use this same data frame for multiple calendar plots if we so wish!\r\n A Note on Wind Direction  Wind direction is a complicated thing to average, as the wind is a vector - it has both a direction (on the compass) and a magnitude (it’s speed). Here I follow this technical note, taking the vector average of the wind direction and the scalar average of the wind speed.\r\n\r\n\r\ncal_df = cal_df %>%\r\n  mutate(wu = ws * sin(2 * pi * wd/360),\r\n         wv = ws * cos(2 * pi * wd/360)) %>%\r\n  group_by(day, wday, week, month, year) %>%\r\n  summarise(across(where(is.numeric), mean, na.rm = T)) %>%\r\n  mutate(wd = (atan2(wu, wv) * 360/2/pi) + 180, .keep = \"unused\") %>%\r\n  ungroup()\r\n\r\n\r\n\r\nLet’s have a look at our data frame now:\r\n\r\n\r\nglimpse(cal_df)\r\n\r\n\r\nRows: 2,731\r\nColumns: 14\r\n$ day   <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...\r\n$ wday  <ord> Sat, Sat, Sat, Sat, Sat, Sat, Sat, Sat, Sat, Sat, S...\r\n$ week  <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...\r\n$ month <ord> January, January, February, March, April, May, May,...\r\n$ year  <dbl> 2000, 2005, 2003, 2003, 2000, 1999, 2004, 2002, 200...\r\n$ ws    <dbl> 2.375000, 6.466667, 3.858333, 4.425000, 3.940000, 2...\r\n$ wd    <dbl> 60.5088499, 53.6412623, 64.5840029, 3.5529869, 342....\r\n$ nox   <dbl> 210.16667, 112.50000, 204.54167, 208.62500, 224.416...\r\n$ no2   <dbl> 41.45833, 48.08333, 55.75000, 65.37500, 50.70833, 5...\r\n$ o3    <dbl> 1.500000, 6.500000, 3.083333, 3.000000, 4.833333, 8...\r\n$ pm10  <dbl> 30.37500, 20.37500, 31.41667, 36.16667, 34.45833, 4...\r\n$ so2   <dbl> 7.104167, NaN, 4.211806, 4.513889, 3.809722, 5.1099...\r\n$ co    <dbl> 2.5078473, 0.7579024, 1.4006945, 1.5520833, 2.64027...\r\n$ pm25  <dbl> 24.80000, 10.45833, 14.62500, 16.79167, 26.00000, 2...\r\n\r\nPlotting the calendar\r\nThe most basic way to plot a calendar and check that the previous steps have worked correctly is shown below:\r\n\r\n\r\ncal_df %>%\r\n  filter(year == 2000) %>%\r\n  ggplot(aes(x = wday, y = week)) +\r\n  geom_tile(aes(fill = nox)) +\r\n  facet_wrap(~month) +\r\n  scale_y_reverse()\r\n\r\n\r\n\r\n\r\nThis is obviously really awful to look at, so over a few iterations we’ll refine it!\r\nThe default ggplot2 theme can be rather unappealing, so I will start by amending the theme and labelling of this plot. The steps I take are:\r\nUse theme_void(), then override it’s removal of the x axis text using theme().\r\nAdd some labels. In the case of the colourbar I use an openair function to format the subscript in NOx, but this naturally will not always be needed.\r\nAbbreviate the weekday labels using scale_x_discrete().\r\nProvide a coordinate system, coord_equal() to ensure the tiles are square.\r\nChange the colour scheme. Here I’ve ripped the openair “heat” colour scheme, but we could have provided anything.\r\n\r\n\r\ncal_df %>%\r\n  filter(year == 2000) %>%\r\n  \r\n  ggplot(aes(x = wday, y = week)) +\r\n  geom_tile(aes(fill = nox)) +\r\n\r\n  facet_wrap(~month) +\r\n  \r\n  theme_void() +\r\n  theme(axis.text.x = element_text()) +\r\n  \r\n  labs(fill = openair::quickText(\"NOx / ppb\")) +\r\n  \r\n  scale_y_reverse() +\r\n  scale_x_discrete(labels = c(\"S\",\"S\",\"M\",\"T\",\"W\",\"T\",\"F\")) +\r\n  \r\n  scale_fill_gradientn(colors = openair::openColours(scheme = \"heat\"), \r\n                       na.value = \"grey80\", \r\n                       breaks = c(100,300,500)) +\r\n  \r\n  coord_equal()\r\n\r\n\r\n\r\n\r\nOne thing that looks rather weird is the unusual shapes that have emerged from using theme_void(). We can create some dummy data to “fill out” the rest of each facet. To do so, I use purrr’s crossing() function to create a “complete” grid of tiles for each combination of month, week and wday in the cal_df data frame. I then plot this data frame using geom_tile() first to provide a back-drop to our actual calendar plot. I use color = \"white\" for both geom_tile()s to add some contrast between them.\r\n\r\n\r\ndummy = crossing(wday = unique(cal_df$wday),\r\n                 week = unique(cal_df$week),\r\n                 month = unique(cal_df$month))\r\n\r\n\r\n\r\n\r\n\r\ncal_df %>%\r\n  filter(year == 2000) %>%\r\n  \r\n  ggplot(aes(x = wday, y = week)) +\r\n  geom_tile(data = dummy, fill = \"grey95\", color = \"white\") +\r\n  geom_tile(aes(fill = nox), color = \"white\") +\r\n\r\n  facet_wrap(~month) +\r\n  \r\n  theme_void() +\r\n  theme(axis.text.x = element_text()) +\r\n  \r\n  labs(fill = openair::quickText(\"NOx / ppb\")) +\r\n  \r\n  scale_y_reverse() +\r\n  scale_x_discrete(labels = c(\"S\",\"S\",\"M\",\"T\",\"W\",\"T\",\"F\")) +\r\n  \r\n  scale_fill_gradientn(colors = openair::openColours(scheme = \"heat\"), \r\n                       na.value = \"grey80\", \r\n                       breaks = c(100,300,500)) +\r\n  \r\n  coord_equal()\r\n\r\n\r\n\r\n\r\nA clear ommission from the original openair plot is that we have yet to visualise wind speed or direction. Thankfully, ggplot2 provides geom_spoke() - another geometry I do not find myself using particularly often. Because geom_spoke() uses the cos() and sin() functions to calculate angles, our wd column needs a little playing with.\r\nTo my knowledge, geom_spoke() also pivots around a centre point and cannot be readily extended backwards like the tail of a weathercock, as is the visualisation of the openair calendar. This means that a potentailly wide range of wind speeds will be represented by a relatively tiny change in the length of the arrow. Instead I choose to use a point, the size of which will be relative to wind speed instead.\r\n\r\n\r\ncal_df %>%\r\n  filter(year == 2000) %>%\r\n  \r\n  ggplot(aes(x = wday, y = week)) +\r\n  geom_tile(data = dummy, fill = \"grey95\", color = \"white\") +\r\n  geom_tile(aes(fill = nox), color = \"white\") +\r\n  \r\n  geom_spoke(aes(angle = ((-wd+90)/360)*2*pi), radius = .4, arrow = arrow(length = unit(.1,\"cm\"))) +\r\n  geom_point(aes(size = ws)) +\r\n\r\n\r\n  facet_wrap(~month) +\r\n  \r\n  theme_void() +\r\n  theme(axis.text.x = element_text()) +\r\n  \r\n  labs(fill = openair::quickText(\"NOx / ppb\"),\r\n       size = openair::quickText(\"Wind Speed / m/s\")) +\r\n  \r\n  scale_y_reverse() +\r\n  scale_x_discrete(labels = c(\"S\",\"S\",\"M\",\"T\",\"W\",\"T\",\"F\")) +\r\n  \r\n  scale_fill_gradientn(colors = openair::openColours(scheme = \"heat\"), \r\n                       na.value = \"grey80\") +\r\n  scale_size(range = c(0,4)) +\r\n\r\n  coord_equal()\r\n\r\n\r\n\r\n\r\nNow it’s “ready to go” I’ll just throw a title on it for some-last minute theme-ing.\r\n\r\n\r\ncal_df %>%\r\n  filter(year == 2000) %>%\r\n  \r\n  ggplot(aes(x = wday, y = week)) +\r\n  geom_tile(data = dummy, fill = \"grey95\", color = \"white\") +\r\n  geom_tile(aes(fill = nox), color = \"white\") +\r\n  \r\n  geom_spoke(aes(angle = ((-wd+90)/360)*2*pi), radius = .4, arrow = arrow(length = unit(.1,\"cm\"))) +\r\n  geom_point(aes(size = ws)) +\r\n\r\n\r\n  facet_wrap(~month) +\r\n  \r\n  theme_void() +\r\n  theme(axis.text.x = element_text(),\r\n        plot.title.position = \"plot\", \r\n        plot.caption.position = \"plot\",\r\n        plot.title = element_text(size = 20),\r\n        plot.subtitle = element_text(size = 15, color = \"grey40\"),\r\n        plot.caption = element_text(size = 7, color = \"grey50\", hjust = 0)) +\r\n  \r\n  labs(fill = openair::quickText(\"NOx / ppb\"),\r\n       size = openair::quickText(\"Wind Speed / m/s\"),\r\n       title = \"Nitrogen Oxides in Marylebone, London\",\r\n       subtitle = \"How concentrations of nitrogen oxides changed through the year 2000.\\n\",\r\n       caption = \"\\nData from {openair} | Visualisation by Jack Davison (@JDavison_)\") +\r\n  \r\n  scale_y_reverse() +\r\n  scale_x_discrete(labels = c(\"S\",\"S\",\"M\",\"T\",\"W\",\"T\",\"F\")) +\r\n  \r\n  scale_fill_gradientn(colors = openair::openColours(scheme = \"heat\"), \r\n                       na.value = \"grey80\") +\r\n  scale_size(range = c(0,4)) +\r\n\r\n  coord_equal()\r\n\r\n\r\n\r\n\r\nClosing thoughts, and calendars “in the wild”\r\nCalendar plots are relatively niche and their applications are pretty limited - they can effectively only plot time series data at a daily resolution. At a higher resolution you need to average or sum and lose detail, and at a lower resolution (e.g. weekly, monthly, yearly data) you cannot calendarify the data in the way we have here.\r\nWhile openair is designed for air quality data, there is no reason to necessarily restrict ourselves to data from just even the wider umbrella of environmental science. For example, in a recent #TidyTuesday challenge about homelessness I noted some rather interesting calendar plots!\r\nThere was this plot, similar to what I have laid out here:\r\n\r\n\r\nToday's #TidyTuesday plot, looking at the occupancy rate of shelters in Toronto in 2019. Coming into the winter months, donations are needed now more than ever.More information here: https://t.co/pJpgVzyaE3 pic.twitter.com/k93B9EsezQ\r\n\r\n— Henry Wakefield (@henrywrover2) December 1, 2020\r\n\r\nA “GitHub-style” calendar:\r\n\r\n\r\nGot back on the #rstats #TidyTuesday train this week looking at Toronto Homeless Shelters. I made a github-style calendar showing the number of programs at or above capacity on each day. I can see some seasonal trend (esp in 2018), but not as much as I was expecting pic.twitter.com/gYnlbLQldy\r\n\r\n— Amanda Luby, PhD (@amandaluby) December 2, 2020\r\n\r\nAnd even a “calendar in disguise” which has all the elements of a calendar plot, but uses a different categorical variable (in this case a shelter provider) in place of the day of the year.\r\n\r\n\r\nToronto shelters for this week’s #TidyTuesday code: https://t.co/QK77DGL8g1#dataviz #RStats pic.twitter.com/zhNeuieP5W\r\n\r\n— Georgios Karamanis (@geokaramanis) December 2, 2020\r\n\r\nSo perhaps calendar plots aren’t going to be useful for every project, but they’re a useful one to have in your back pocket!\r\n\r\n\r\n\r\n",
    "preview": "posts/2020-12-30-tutorial-calendar-plots-using-ggplot2/tutorial-calendar-plots-using-ggplot2_files/figure-html5/unnamed-chunk-14-1.png",
    "last_modified": "2020-12-31T19:47:43+00:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-12-29-creating-a-function-counting-coins/",
    "title": "The Minimum Coins Problem in Base R",
    "description": "An R-based solution to a common programming challenge - for a given value of money, what is the minimum number of coins to make the change?",
    "author": [
      {
        "name": "Jack Davison",
        "url": {}
      }
    ],
    "date": "2020-12-29",
    "categories": [
      "tutorial"
    ],
    "contents": "\r\n\r\nContents\r\nSetting the scene\r\nWriting a basic function\r\nExpanding the function\r\nReturning the list of coins\r\nAllowing for similar currencies\r\nThe curious case of the Canadian Dollar\r\nSaving users from themselves\r\n\r\nInsights and Visualisations\r\nClosing Thoughts\r\n\r\nSetting the scene\r\nThe internet is awash with common programming “interview-style” challenges, perhaps most famously “fizzbuzz”. A problem that I recently became aware of was the “minimum coins” puzzle, defined as such:\r\n\r\nGiven a value V, if we want to make change for V cents, and we have infinite supply of each of C = { C1, C2, .. , Cm} valued coins, what is the minimum number of coins to make the change?\r\n\r\nThe linked blog features answers for many languages - C++, Java, Python, etc. - but R is a notable omission. I thought I’d try to generate a complementary answer, so if anyone happens to Google an R-based answer, here it will be!\r\nWriting a basic function\r\nWhen I write a function, I try to write the most basic workable version of it first. My thoughts going into this were as follows:\r\nAs a first step, we’ll need to define the coins we’ll be using. As I’m British, I’ll use GBP.\r\nWe’ll then need to find the greatest value coin that itself is greater than the value, V, which we can call B.\r\nOnce we have identified B, we’ll need to subtract B from V and repeat from Step 2 until V = 0.\r\nWe’ll need to count each iteration of Steps 2-3 and return that counted value.\r\nMy attempt is given below:\r\n\r\n\r\ncount_coins = function(v){\r\n  \r\n  coins = c(1, 2, 5, 10, 20, 50, 100, 200)\r\n\r\n  result = c()\r\n  \r\n  while(v > 0){\r\n    \r\n    b = max(coins[coins <= v])\r\n    \r\n    result = append(result, b)\r\n    \r\n    v = v - b\r\n    \r\n  }\r\n  \r\n  return(length(result))\r\n\r\n}\r\n\r\n\r\n\r\nHere the available coins are stored as a vector named coins. I’ve chosen not to use decimals (i.e. 2p = 2, not .02) for a reason that will become apparent later. I then have an empty results vector which will become populated with our coins.\r\nI then use the R function while(), which loops until the condition inside is no longer met. In this case, I have specified that while V is greater than 0, the contents within should loop. Those contents identify the greatest value in the coins vector that’s greater than or equal to V, add it to our results vector, and then subtract it from V.\r\nThe function finally returns the length of the results vector. So now, in theory, we can provide our function any values in pence and it’ll return the minimum number of coins you’d need. So for example, if we use V = 8 we’d expect 3 coins - 5p + 2p + 1p.\r\n\r\n\r\ncount_coins(v = 8)\r\n\r\n\r\n[1] 3\r\n\r\nAs the UK has 10p coins, V = 10 should return 1 coin.\r\n\r\n\r\ncount_coins(v = 10)\r\n\r\n\r\n[1] 1\r\n\r\nWe could also throw it a larger amount of money - let’s say £5.12 (V = 512). I would predict £2 + £2 + £1 + 10p + 2p = 5 coins.\r\n\r\n\r\ncount_coins(v = 512)\r\n\r\n\r\n[1] 5\r\n\r\nLooking good!\r\nExpanding the function\r\nReturning the list of coins\r\nThis would hopefully tick whatever box the interviewer was looking to tick, but we can do better. If we were a frequent counter of coins, we may want additional features. For example, we may want an option to return the actual coins rather than simply the number of them. This will also be a good double-check that the function isn’t doing anything wacky behind the scenes and just happening upon the correct answer! It is also a pretty easy addition:\r\n\r\n\r\ncount_coins = function(v, return_coins = F){\r\n  \r\n  coins = c(1, 2, 5, 10, 20, 50, 100, 200)\r\n\r\n  result = c()\r\n  \r\n  while(v > 0){\r\n    \r\n    b = max(coins[coins <= v])\r\n    \r\n    result = append(result, b)\r\n    \r\n    v = v - b\r\n    \r\n  }\r\n  \r\n  if (return_coins) {\r\n    return(result)\r\n  } else {\r\n    return(length(result))\r\n  }\r\n  \r\n\r\n}\r\n\r\n\r\n\r\nLet’s revisit the arbitrary value of £5.12.\r\n\r\n\r\ncount_coins(v = 512, return_coins = F)\r\n\r\n\r\n[1] 5\r\n\r\ncount_coins(v = 512, return_coins = T)\r\n\r\n\r\n[1] 200 200 100  10   2\r\n\r\nAllowing for similar currencies\r\nAnother obvious addition could be the addition of different currencies other than GBP. There are two ways we could approach this:\r\nWe could allow users to enter their own vector of coins.\r\nWe could allow users to enter a currency code and have these values built-in, e.g. “GBP”, “USD”, “JPY”, etc.\r\nThere is no reason, however, to not do both! Such is the flexibility of writing functions in R. I will add a feature that checks to see if the user has entered a character string or numeric vector.\r\nIf the user has entered a character string, it will check it against the hard-coded coin values and give a warning if whatever they have specified is not included.\r\nIf the user has entered a numeric vector, it will set the coins vector to be equal to it. To avoid infinite loops, it will also append the number 1.\r\nFor the sake of this example, I’m going to hard-code the Great British Pound, the Euro, the US Dollar, and the Japanese Yen as four common currencies. This is the reason I did not use decimals - the Japanese Yen does not, and it would only serve to introduce awkwardness if we want to make comparisons between the different coin types (spoilers: that is coming next!).\r\n\r\n\r\ncount_coins = function(v, return_coins = F, coin_vals = \"GBP\"){\r\n  \r\n  if (is.character(coin_vals)) {\r\n    if (coin_vals %in% c(\"GBP\", \"EUR\")) {\r\n      coins = c(1, 2, 5, 10, 20, 50, 100, 200)\r\n    } else if (coin_vals == \"USD\") {\r\n      coins = c(1, 5, 10, 25, 50, 100)\r\n    } else if (coin_vals == \"JPY\") {\r\n      coins = c(1, 5, 10, 50, 100, 500)\r\n    } else {\r\n      warning(\r\n        paste0(\r\n          \"The currency '\",\r\n          coin_vals,\r\n          \"' is not supported. Supported currencies are GBP, EUR, USD, and JPY.\r\n          Alternatively, provide a vector of numeric coin values.\"\r\n        )\r\n      )\r\n      stop()\r\n    }} else if (is.numeric(coin_vals)) {\r\n    coins = append(coin_vals,1)\r\n  }\r\n  \r\n  result = c()\r\n\r\n  while(v > 0){\r\n\r\n    b = max(coins[coins <= v])\r\n\r\n    result = append(result, b)\r\n\r\n    v = v - b\r\n\r\n  }\r\n\r\n  if (return_coins) {\r\n    return(result)\r\n  } else {\r\n    return(length(result))\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n\r\nLet’s try a few examples:\r\n\r\n\r\ncount_coins(v = 512, return_coins = T, coin_vals = \"EUR\")\r\n\r\n\r\n[1] 200 200 100  10   2\r\n\r\ncount_coins(v = 512, return_coins = T, coin_vals = \"USD\")\r\n\r\n\r\n[1] 100 100 100 100 100  10   1   1\r\n\r\ncount_coins(v = 512, return_coins = T, coin_vals = \"JPY\")\r\n\r\n\r\n[1] 500  10   1   1\r\n\r\ncount_coins(v = 512, return_coins = T, coin_vals = c(5,500))\r\n\r\n\r\n[1] 500   5   5   1   1\r\n\r\ncount_coins(v = 512, return_coins = T, coin_vals = \"CAD\")\r\n\r\n\r\nWarning in count_coins(v = 512, return_coins = T, coin_vals = \"CAD\"): The currency 'CAD' is not supported. Supported currencies are GBP, EUR, USD, and JPY.\r\n          Alternatively, provide a vector of numeric coin values.\r\nError in count_coins(v = 512, return_coins = T, coin_vals = \"CAD\"): \r\n\r\nThe curious case of the Canadian Dollar\r\nIn Canada and Australia the decision was made to stop minting coins below a value of 5¢. This is very sensible, but introduces an interesting problem for the function - currently, to avoid infinite recursion, we append a 1¢ (or 1p, or whatever) coin to any list - but this won’t actually reflect the situation in Canada or Australia. The Wikipedia article on the Abolition of the Canadaian penny writes:\r\n\r\nCash transactions are now rounded to the nearest 5¢. The rounding is not done on individual items but on the total bill of sale, with totals ending in 1, 2, 6, or 7 rounded down to 0 or 5, and totals ending in 3, 4, 8, or 9 rounded up.\r\n\r\nThe solution to this issue could be more complicated than it needs to be. If the question that this function serves to answer is “If I have V Canadian cents in my bank account and convert that to cash, how many coins are now in my wallet?” then the value of V we use within the while() loop will have to be some value that is divisible by five.\r\nTo overcome this, we could simply round V down to the nearest multiple of five using the floor() function, which is similar to round() but always rounds down. Rather than hard-coding a value of 5, I can just identify the smallest unit of currency inside of the coins vector and use that - this allows for any coins to be used. Note that this means I can get rid of appending the 1¢ coin to a user-defined numeric vector.\r\n\r\n\r\ncount_coins = function(v, return_coins = F, coin_vals = \"GBP\"){\r\n  \r\n  if (is.character(coin_vals)) {\r\n    if (coin_vals %in% c(\"GBP\", \"EUR\")) {\r\n      coins = c(1, 2, 5, 10, 20, 50, 100, 200)\r\n    } else if (coin_vals == \"USD\") {\r\n      coins = c(1, 5, 10, 25, 50, 100)\r\n    } else if (coin_vals == \"JPY\") {\r\n      coins = c(1, 5, 10, 50, 100, 500)\r\n    } else if (coin_vals == \"CAD\") {\r\n      coins = c(5, 10, 25, 100, 200)\r\n    } else if (coin_vals == \"AUD\") {\r\n      coins = c(5, 10, 20, 50, 100, 200)\r\n    } else {\r\n      warning(\r\n        paste0(\r\n          \"The currency '\",\r\n          coin_vals,\r\n          \"' is not supported. Supported currencies are GBP, EUR, USD, CAD, AUD and JPY.\r\n          Alternatively, provide a vector of numeric coin values.\"\r\n        )\r\n      )\r\n      stop()\r\n      \r\n  }} else if (is.numeric(coin_vals)) {\r\n    coins = coin_vals\r\n  }\r\n  \r\n  v = floor(v/min(coins))*min(coins)\r\n\r\n  result = c()\r\n\r\n  while(v > 0){\r\n\r\n    b = max(coins[coins <= v])\r\n    \r\n    result = append(result, b)\r\n\r\n    v = v - b\r\n\r\n  }\r\n\r\n  if (return_coins) {\r\n    return(result)\r\n  } else {\r\n    return(length(result))\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n\r\nLet’s test this out:\r\n\r\n\r\ncount_coins(v = 512, return_coins = T, coin_vals = \"CAD\")\r\n\r\n\r\n[1] 200 200 100  10\r\n\r\ncount_coins(v = 512, return_coins = T, coin_vals = c(10, 20, 60))\r\n\r\n\r\n [1] 60 60 60 60 60 60 60 60 20 10\r\n\r\nSaving users from themselves\r\nThis seems to work well, but has highlighted a danger of allowing the manual input of coin values - infinite recursion. For example, the following will loop infinitely:\r\n\r\n\r\ncount_coins(v = 512, return_coins = T, coin_vals = c(9, 23, 64))\r\n\r\n\r\n\r\nI have intuited (perhaps incorrectly!) that each coin value needs to be divisible by the lowest coin value to work. So this is an appropriate list of coins and will not loop forever:\r\n\r\n\r\ncount_coins(v = 512, return_coins = T, coin_vals = c(9, 27, 63))\r\n\r\n\r\n[1] 63 63 63 63 63 63 63 63\r\n\r\nOne way we can stop the function breaking is introducing a check using all() and the modulus operator %% which stops the function before the loop.\r\n\r\n\r\ncount_coins = function(v, return_coins = F, coin_vals = \"GBP\"){\r\n  \r\n  if (is.character(coin_vals)) {\r\n    if (coin_vals %in% c(\"GBP\", \"EUR\")) {\r\n      coins = c(1, 2, 5, 10, 20, 50, 100, 200)\r\n    } else if (coin_vals == \"USD\") {\r\n      coins = c(1, 5, 10, 25, 50, 100)\r\n    } else if (coin_vals == \"JPY\") {\r\n      coins = c(1, 5, 10, 50, 100, 500)\r\n    } else if (coin_vals == \"CAD\") {\r\n      coins = c(5, 10, 25, 100, 200)\r\n    } else if (coin_vals == \"AUD\") {\r\n      coins = c(5, 10, 20, 50, 100, 200)\r\n    } else {\r\n      warning(\r\n        paste0(\r\n          \"The currency '\",\r\n          coin_vals,\r\n          \"' is not supported. Supported currencies are GBP, EUR, USD, CAD, AUD and JPY.\r\n          Alternatively, provide a vector of numeric coin values.\"\r\n        )\r\n      )\r\n      stop()\r\n      \r\n  }} else if (is.numeric(coin_vals)) {\r\n    coins = coin_vals\r\n  }\r\n  \r\n  v = floor(v/min(coins))*min(coins)\r\n  \r\n  if (!all(coins %% min(coins) == 0)) {\r\n    warning(paste(\"Ensure all coins are divisible by\",\r\n                  min(coins),\r\n                  \"to avoid infinite recursion.\"))\r\n    stop()\r\n  }\r\n\r\n  result = c()\r\n\r\n  while(v > 0){\r\n\r\n    b = max(coins[coins <= v])\r\n    \r\n    if (is.null(b)) {\r\n      stop()\r\n    }\r\n\r\n    result = append(result, b)\r\n\r\n    v = v - b\r\n\r\n  }\r\n\r\n  if (return_coins) {\r\n    return(result)\r\n  } else {\r\n    return(length(result))\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n\r\nOur dodgy set of coins should now fail rather than go on indefinitely:\r\n\r\n\r\ncount_coins(v = 512, return_coins = T, coin_vals = c(9, 23, 64))\r\n\r\n\r\nWarning in count_coins(v = 512, return_coins = T, coin_vals = c(9, 23,\r\n64)): Ensure all coins are divisible by 9 to avoid infinite recursion.\r\nError in count_coins(v = 512, return_coins = T, coin_vals = c(9, 23, 64)): \r\n\r\nInsights and Visualisations\r\nWith a more fully featured function like this, we can gain some fairly pointless insights about how the values of coins affect the numbers of coins you actually have in your wallet. I’m going to create some visualisations using ggplot2 and the tidyverse. For ease, I’m going to pre-set my theme using the ggthemr package.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(ggthemr)\r\n\r\nggthemr::ggthemr(palette = \"flat\",\r\n                 text_size = 14,\r\n                 layout = \"scientific\")\r\n\r\n\r\n\r\nLet’s use our function on values from 1 to 5000 units of currency (i.e. 1p to £50, 1¢ to $50, and ¥1 to ¥5000). We’ll use the dplyr function rowwise() to facilitate this.\r\n\r\n\r\ndf = data.frame(val = 1:5000) %>%\r\n  rowwise() %>%\r\n  mutate(coin_gbp = count_coins(v = val, coin_vals = \"GBP\"),\r\n         coin_usd = count_coins(v = val, coin_vals = \"USD\"),\r\n         coin_jpy = count_coins(v = val, coin_vals = \"JPY\"))\r\n\r\n\r\n\r\nLet’s plot our findings. This should let us see which set of coin values will give us the fewest number of physical coins on our person. NB: There is currently a bug in the most recent version of ggthemr; the last line should not be necessary in future!\r\n\r\n\r\ndf %>%\r\n  pivot_longer(contains(\"coin\"),\r\n               names_to = \"currency\",\r\n               values_to = \"number\") %>%\r\n  mutate(currency = toupper(str_remove_all(currency, \"coin_\"))) %>%\r\n  ggplot(aes(x = val, y = number, color = currency)) + \r\n  geom_point(alpha = .05) +\r\n  geom_smooth(se = F) +\r\n  theme(\r\n    plot.title.position = \"plot\",\r\n    plot.caption.position = \"plot\",\r\n    legend.position = \"top\", \r\n    plot.margin = unit(rep(1,4), \"cm\")\r\n  ) +\r\n  labs(x = \"Amount of Money\", y = \"Number of Coins\",\r\n       title = \"Currency to Coinage\",\r\n       subtitle = \"How the same decimal amount of money affects the number of coins in your wallet.\",\r\n       caption = \"Visualisation by Jack Davison (@JDavison_)\",\r\n       color = \"\") +\r\n  scale_color_manual(values = ggthemr::swatch()) \r\n\r\n\r\n\r\n\r\nThe results are perhaps unsurprising. The US lacks a large coin, so for larger monetary values the number of coins rapidly increase. The GBP lies in the middle, having both a £1 and £2 coin. Of most interest is the JPY - the largest coins are ¥100 and ¥500 - ¥400 between them. This large gap magnifies a repeating pattern of a large drop every 500 units of currency.\r\nThese relationships appear to be roughly linear, so we could do some linear modelling to transform one currency into the other. The real world use of this is extremely limited, but it answers the question of “if you had X coins in the US, the US suddenly abandoned the 25¢ coin in favour of a 20¢ one and gained a $2 coin, how many coins would you likely have instead?”, a question I am sure has plagued economists for centuries!\r\n\r\n\r\neq = df %>%\r\n  pivot_longer(coin_usd:coin_jpy) %>%\r\n  mutate(name = if_else(name == \"coin_usd\", \"US Dollars/Cents\", \"Japanese Yen\")) %>%\r\n  nest_by(name) %>%\r\n  mutate(mod = list(lm(coin_gbp ~ value, data = data))) %>%\r\n  summarise(broom::tidy(mod)) %>%\r\n  select(name, term, estimate) %>%\r\n  pivot_wider(names_from = term, values_from = estimate) %>%\r\n  janitor::clean_names() %>%\r\n  mutate(equation = glue::glue(\"y = {round(intercept,2)} + {round(value,2)}x\"))\r\n\r\ndf %>%\r\n  pivot_longer(coin_usd:coin_jpy) %>%\r\n  mutate(name = if_else(name == \"coin_usd\", \"US Dollars/Cents\", \"Japanese Yen\")) %>%\r\n  ggplot(aes(x = value, y = coin_gbp)) +\r\n  geom_abline(color = swatch()[1], lty = 2, size = 1) +\r\n  geom_count(aes(color = name), alpha = .5) +\r\n  geom_smooth(method = \"lm\", color = swatch()[5]) +\r\n  labs(x = \"Number of Local Coins\", \r\n       y = \"Number of GB Coins\",\r\n       title = \"Coinage: What If?\",\r\n       subtitle = \"What if the US or Japan had coins more like the UK?\",\r\n       caption = \"Visualisation by Jack Davison (@JDavison_)\") +\r\n  geom_text(data = eq, inherit.aes = F, aes(label = equation, x = 10, y = 32.5), size = 4,\r\n            color = swatch()[5]) +\r\n  facet_grid(~name, space = \"free\", scales = \"free_x\", switch = \"x\") +\r\n  theme(legend.position = \"top\", \r\n        plot.title.position = \"plot\",\r\n        plot.caption.position = \"plot\",\r\n        strip.placement = \"outside\", \r\n        plot.margin = unit(rep(1,4), \"cm\")) +\r\n  guides(color = F) +\r\n  scale_x_continuous(breaks = seq(0,60,10)) +\r\n  scale_color_manual(values = ggthemr::swatch()) \r\n\r\n\r\n\r\n\r\nSo in this magical scenario where the global community suddenly decides to mint coins in a GBP-style, a US citizen walking around with 10 coins in his pocket would suddenly find himself with only 7. Conversely, a Japanese person would likely find themselves with 14!\r\nClosing Thoughts\r\nThis was simply an exercise in solving a basic programming challenge in Base R, taking the problem further, and then seeing if anything insightful can be seen (answer: not really anything that insightful!).\r\nIs there anything else that could be added to such a function? And is the way of dealing with AUD and CAD the best approach?\r\n\r\n\r\n\r\n",
    "preview": "posts/2020-12-29-creating-a-function-counting-coins/creating-a-function-counting-coins_files/figure-html5/unnamed-chunk-17-1.png",
    "last_modified": "2020-12-31T20:25:10+00:00",
    "input_file": "creating-a-function-counting-coins.utf8.md"
  }
]
