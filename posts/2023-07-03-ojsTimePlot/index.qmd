---
title: "Air Quality Time Series in Observable Plot"
description: |
  Creating smart, interactive, web-based time series in quarto reports.
image: banner.jpg
categories: [visualisation, observable, airquality]
author: "Jack Davison"
date: 2023/07/03
twitter-card:
  image:  "banner.jpg"
  card-style: summary_large_image
execute: 
  warning: false
  message: false
  error: false
  echo: fenced
  eval: false
editor_options: 
  chunk_output_type: console
draft: true
---

# Introduction

## Purpose

This blog post demonstrates plotting air quality time series for use in quarto documents. First we'll do it in R, but then I'll introduce Observable Plot, a JavaScript library for making high-quality, web-based plots of all shapes and sizes. While you may worry that you're not a JavaScript programmer (spoilers: neither am I!) you'll hopefully see that it is not too tricky to learn at all. Plus, it is built-in to [Quarto](https://quarto.org/), so if you're an R, Python or Julia user it's only a small leap to start creating interactive web graphics for your next data-driven report.

## Data

To plot some AQ time series, we first need some data. I'm going to use `{openair}` to import NO~x~ data from Marylebone Road in 2019. I'll then average it to daily concentrations, and pivot it longer. You can see a summary of this data in @tbl-info.

```{r}
#| label: tbl-info
#| tbl-cap: "A summary of our `aq_data` dataframe."
# import AQ data
aq_data <- openair::importAURN("my1", year = 2019, pollutant = c("nox", "no2")) 

# average to daily
aq_data <- openair::timeAverage(aq_data, "day")

# tidy
aq_data_long <- tidyr::pivot_longer(aq_data, -date, names_to = "pollutant", values_to = "value")

# capitalise pollutants
aq_data_long$pollutant <- toupper(aq_data_long$pollutant)

# view
gtsummary::tbl_summary(aq_data_long, by = "pollutant")
```

# R plotting

Now, let's briefly outline how we might make roughly the same air quality time series using four common packages - `{openair}`, `{ggplot2}`, `{plotly}` and `{dygraphs}`. I'm going to try my best to ensure that they all look as similar as possible, to give a proper like-for-like comparison.

::: {.panel-tabset}

## `{openair}` (`{lattice}`)

`{openair}` is the oldest package in this list and the most dedicated to air quality. When `openair::timePlot()` was first authored, `{lattice}` was common, `{ggplot2}` was slow and incomplete, and it was generally tricky to create a good looking time series in R. Nowadays that isn't the case, but `{openair}` has some key advantages, such as built-in time averaging and automatic formatting of common air quality pollutant names and units.

```{r}
#| label: fig-openair
#| fig-cap: "A timeseries built using `{openair}`."
library(openair)
timePlot(
  aq_data,
  c("nox", "no2"),
  group = TRUE,
  cols = c("royalblue", "tomato"),
  ylab = c("conc. (ug/m3)"),
  key.position = "top"
)
```

## `{ggplot2}`

`{ggplot2}` needs no introduction. It is one of the most common methods of plotting in R, (almost!) endlessly extensible. It is much less prescriptive than `{openair}`, which means users get much more control over their outputs, but equally have to work that bit harder! Plots are composed by adding (`+`) geometries, stats, themes, scales, etc. to a base `ggplot()` object, and by mapping dataframe columns to different aesthetics (x, y, color, size, alpha, etc.).

```{r}
#| label: fig-ggplot2
#| fig-cap: "A timeseries built using `{ggplot2}`."
library(ggplot2)
ggplot(aq_data_long, aes(x = date, y = value, color = pollutant)) +
  geom_line() +
  theme_bw() +
  theme(legend.position = "top") +
  scale_color_manual(values = c("tomato", "royalblue")) +
  labs(
    x = NULL,
    y = openair::quickText("conc. (ug/m3)"),
    color = NULL
  )
```

## `{plotly}`

`{plotly}` is a wrapper around the javascript library of the same name. The R implementation uses similar syntax to `{ggplot2}`, so its not too tricky to jump from one to the other. The key differences are that the base object, defined with `plot_ly()` is *piped into* functions rather than *added to* them, and the aesthetics are given using "formula syntax". The key benefit of `{plotly}` is it is inherently interactive, which means readers can easily learn more about the data by reading tooltips or zooming in on it.

```{r}
#| label: fig-plotly
#| fig-cap: "A timeseries built using `{plotly}`."
library(plotly)
plot_ly(
  aq_data_long,
  x = ~ date,
  y = ~ value,
  color = ~ pollutant,
  colors = c("tomato", "royalblue")
) %>%
  add_lines() %>%
  layout(xaxis = list(title = ""),
         yaxis = list(title = "conc. (μg m⁻³)"),
         legend = list(orientation = "h", y = 1.2))
```
:::

## `{dygraphs}`

I'm going to be honest - I'm not a huge fan of how `{dygraphs}` outputs look! It can also be a bit of a pain to get your data in the right structure to keep the package happy. However, the key positives of this package is that its entirely dedicated to time series and can quite quickly put together an interactive plot.

```{r}
#| label: fig-dygraphs
#| fig-cap: "A timeseries built using `{dygraphs}`."
library(dygraphs)
aq_data %>%
  dplyr::rename_with(toupper, -date) %>%
  dygraph() %>%
  dyAxis("y", "conc. (μg m⁻³)") %>%
  dyOptions(colors = c("royalblue", "tomato"))
```

# Observable


:::{.column-margin}
:::{.callout-note appearance="simple" title="ojs chunks"}
Notice that we're now starting to write in {ojs} chunks. You can't write R (or Python/Julia) code in these, nor can they be run interactively.
:::
:::

## Data Tranfer to OJS

First, we need to pass our data to observable using the built-in quarto `ojs_define()` functionality. Note that this won't run interactively, but will be properly run when the document is compiled.

```{r}
ojs_define(aq_data_raw = aq_data_long)
```

```{ojs}
//| output: all
aq_data_raw
```

One issue that needs resolving is that `ojs_define()` changes R dates to character strings, meaning that we need to write the javascript to fix this. This next chunk is taken directly from [this StackOverflow post](https://stackoverflow.com/questions/76499928/passing-dates-from-r-chunk-to-ojs-chunk-using-ojs-define-in-quarto), but effectively is importing JavaScript libraries necessary to parse the "date" column as a "date".

1. The first line is importing [arquero](https://uwdata.github.io/arquero/), a JavaScript data manipulation library similar to `{dplyr}`.

2. The second line imports [d3](https://d3js.org/), the JavaScript library that Plot is built on. d3 is *a lot* more complicated to plot with, but all we need from it here is a datetime parser.

3. The third line sets up a parser that is expecting a "YYYY-MM-DD HH:MM:SS" string to transform into a date.

```{ojs}
import { aq } from '@uwdata/arquero'
d3 = require("d3@7")
parser = d3.timeParse("%Y-%m-%d");
```

The below chunk is then taking our `aq_data_raw` OJS object and formatting it properly for Observable Plot. There are two steps here:

1. `transpose()` is turning the column-based R (or Python) dataframe into a row-based JavaScript data structure.

2. `derive()` is our `mutate()` equivalent from `arquero`, and is using the parser to transform the data.

```{ojs}
aq_data = aq.from(transpose(aq_data_raw))
  .derive({ date: aq.escape(d => parser(d.date)) })
```

```{ojs}
//| output: all
aq_data
```

Phew, we're done! Don't worry if that didn't make 100% sense, it can be usefully used as a template to jump from your R data to an Observable-ready data structure in most cases.

## Plotting in OJS

Now we're finally going to make our plot! The result of all this is @fig-ojs, seen below.

```{ojs}
//| label: fig-ojs
//| fig-cap: "A timeseries built using Observable Plot."
Plot.plot({
  y: {label: "conc. (μg m⁻³)", grid: true},
  color: {
    type: "categorical",
    range: ["#456ce4", "#fc6445"],
    legend: true
  },
  marks: [
    Plot.line(aq_data, {x: "date", y: "value", stroke: "pollutant"})
  ],
})
```

Let's unpack the code above.

* We're referring to the Observable Plot library using `Plot.fun()` syntax. This is similar to doing `pkg::fun()` in R or `lib.fun()` in Python.

* `Plot.plot({})` is the bedrock on which we build our plot. This is not unlike starting a `{ggplot2}` plot with `ggplot2::ggplot()`, or a `{plotly}` plot with `plotly::plot_ly()`. Unlike these functions, however, *everything* goes inside of `Plot.plot({})` (unlike `ggplot()` which is added to, or `plot_ly()` which is piped into other functions).

* All of our geometries are added as an array ([square brackets]) after the `marks:` key. These are the equivalent of `ggplot2::geom_*()` or `plotly::add_*()` functions.

* The equivalents of `ggplot2::scale_*()` functions are additional key-value pairs within `Plot.plot({})`. For example, `y:` takes an object ({curly brackets}) where we can name our axes and add gridlines, and similarly `color:` lets us define our colour scale and whether to draw a legend.

## What's the point?

At this stage, we've successfully recreated the @fig-openair, @fig-ggplot2 and so on in an entirely different programming language that we can't easily run interactively and gives us no helpful popup messages as we type it. So far, the only real benefit is that @fig-ojs does look really smart!

Well, Observable Plot does have some rather nice features we can exploit. For example, the [marker](https://observablehq.com/plot/features/markers) and [curve](https://observablehq.com/plot/features/curves) options make for rather nice looking non-jagged time series.

```{ojs}
//| label: fig-ojssmooth
//| fig-cap: "A smooth time series"
Plot.plot({
  y: {label: "conc. (μg m⁻³)", grid: true},
  color: {
    type: "categorical",
    range: ["#456ce4", "#fc6445"],
    legend: true
  },
  marks: [
    Plot.line(
      aq_data, {
        x: "date", 
        y: "value", 
        stroke: "pollutant", 
        curve: "basis", 
        tension: 0
      }
    )
  ],
})
```

Observable Plot also has a host of [transforms](https://observablehq.com/plot/features/transforms) that can assist in changing our plot output. For air quality time series, we may want to have a rolling mean, maximum or minimum calculated for our data. For example, ozone air quality indices are often defined relative to an 8-hour maximum ozone concentration. This can be easily achieved in Observable.

```{ojs}
//| label: fig-ojsavg
//| fig-cap: "A timeseries built using Observable Plot, averaged to 1 day, 7 days and 30 days."
Plot.plot({
  y: {label: "conc. (μg m⁻³)", grid: true},
  marks: [
    Plot.line(
      aq_data, 
      Plot.windowY(1, {x: "date", y: "value", z: "pollutant", stroke: "#DCDCDC"})
    ),
    Plot.line(
      aq_data, 
      Plot.windowY(7, {x: "date", y: "value", z: "pollutant", stroke: "#808080"})
    ),
    Plot.line(
      aq_data, 
      Plot.windowY(30, {x: "date", y: "value", z: "pollutant", stroke: "#000000"})
    )
  ]
})
```

This leads us nicely onto the most interesting feature of the lot; interactivity. The Observable [inputs](https://observablehq.com/@observablehq/inputs) library gives access to a range of lightweight user interface components that can control plots. In the example below, the user can control the window width and statistic to explore aspects of the data which they are interested in.

```{ojs}
viewof k = Inputs.range([1, 7], {value: 2, step: 1, label: "Window"})
viewof stat = Inputs.radio(["min", "mean", "max"], {value: "mean", label: "Statistic"})
```

```{ojs}
//| label: fig-ojsinput
//| fig-cap: "A timeseries built using Observable Plot, where readers can define their own window widths and summary stats."
Plot.plot({
  y: {label: "conc. (μg m⁻³)", grid: true, domain: [0, 500]},
  color: {
    type: "categorical",
    range: ["#456ce4", "#fc6445"],
    legend: true
  },
  marks: [
    Plot.line(
      aq_data, 
      Plot.windowY({k: k, reduce: stat}, {x: "date", y: "value", stroke: "pollutant"})
  )],
})
```

## Case Study: Ozone Concentrations

```{r}
meta <- importMeta(all = TRUE, year = 2019)

o3_london_meta <-
  dplyr::filter(meta,
                variable == "O3",
                agglomeration == "Greater London Urban Area")

o3_london <-
  importAURN(o3_london_meta$code, year = 2019, pollutant = "o3")

o3_london <-
  selectByDate(o3_london, month = 5)

ojs_define(o3_raw = o3_london)
ojs_define(o3_sites = unique(o3_london$site))
```

```{ojs}
//| echo: false
parser_ymdhms = d3.timeParse("%Y-%m-%d %H:%M:%S");

o3_data = aq.from(transpose(o3_raw))
  .derive({ date: aq.escape(d => parser_ymdhms(d.date)) })
```

```{ojs}
//| echo: false
viewof chosen_site = Inputs.select(o3_sites, { value: ["London Bloomsbury"], label: "Site:"})
```

```{ojs}
//| echo: false
filtered = o3_data.filter(aq.escape(d => d.site === chosen_site));
```

```{ojs}
//| echo: false
//| label: fig-o3
//| fig-cap: "8-hourly averaged ozone concentrations in Greater London."
Plot.plot({
  y: {label: "conc. (μg m⁻³)"},
  marks: [
    Plot.frame(),
    Plot.line(
      filtered, 
      Plot.windowY({k: 8, reduce: "min"}, {x: "date", y: "o3", stroke: "#456ce4"})
    ),
    Plot.line(
      filtered, 
      Plot.windowY({k: 8, reduce: "max"}, {x: "date", y: "o3", stroke: "#fc6445"})
    ),
  ],
})
```

